import type { Wallet } from "@ethersproject/wallet";
import type { JsonRpcSigner } from "@ethersproject/providers";
import { SignatureType } from "@polymarket/order-utils";
import type { SignedOrder } from "@polymarket/order-utils";
import type { BuilderConfig } from "@polymarket/builder-signing-sdk";
import { OrderType, Side } from "./types.ts";
import type { ApiKeyCreds, ApiKeysResponse, Chain, CreateOrderOptions, MarketPrice, OpenOrderParams, OpenOrdersResponse, OrderMarketCancelParams, OrderBookSummary, OrderPayload, Trade, Notification, TradeParams, UserMarketOrder, UserOrder, BalanceAllowanceParams, BalanceAllowanceResponse, OrderScoringParams, OrderScoring, OpenOrder, TickSizes, TickSize, OrdersScoringParams, OrdersScoring, PriceHistoryFilterParams, PaginationPayload, MarketTradeEvent, DropNotificationParams, BookParams, UserEarning, RewardsPercentages, MarketReward, UserRewardsEarning, TotalUserEarning, NegRisk, BanStatus, PostOrdersArgs, FeeRates, BuilderTrade, BuilderApiKey, BuilderApiKeyResponse, ReadonlyApiKeyResponse, HeartbeatResponse } from "./types.ts";
import type { RequestOptions } from "./http-helpers/index.ts";
import { OrderBuilder } from "./order-builder/builder.ts";
import type { IRfqClient } from "./rfq-deps.ts";
export declare class ClobClient {
    readonly host: string;
    readonly chainId: Chain;
    readonly signer?: Wallet | JsonRpcSigner;
    readonly creds?: ApiKeyCreds;
    readonly orderBuilder: OrderBuilder;
    readonly tickSizes: TickSizes;
    readonly negRisk: NegRisk;
    readonly feeRates: FeeRates;
    readonly geoBlockToken?: string;
    readonly useServerTime?: boolean;
    readonly builderConfig?: BuilderConfig;
    readonly rfq: IRfqClient;
    readonly retryOnError?: boolean;
    readonly throwOnError: boolean;
    private tickSizeTimestamps;
    private readonly tickSizeTtlMs;
    constructor(host: string, chainId: Chain, signer?: Wallet | JsonRpcSigner, creds?: ApiKeyCreds, signatureType?: SignatureType, funderAddress?: string, geoBlockToken?: string, useServerTime?: boolean, builderConfig?: BuilderConfig, getSigner?: () => Promise<Wallet | JsonRpcSigner> | (Wallet | JsonRpcSigner), retryOnError?: boolean, tickSizeTtlMs?: number, throwOnError?: boolean);
    getOk(): Promise<any>;
    getServerTime(): Promise<number>;
    getSamplingSimplifiedMarkets(next_cursor?: string): Promise<PaginationPayload>;
    getSamplingMarkets(next_cursor?: string): Promise<PaginationPayload>;
    getSimplifiedMarkets(next_cursor?: string): Promise<PaginationPayload>;
    getMarkets(next_cursor?: string): Promise<PaginationPayload>;
    getMarket(conditionID: string): Promise<any>;
    getOrderBook(tokenID: string): Promise<OrderBookSummary>;
    getOrderBooks(params: BookParams[]): Promise<OrderBookSummary[]>;
    getTickSize(tokenID: string): Promise<TickSize>;
    /**
     * Clears the tick size cache, forcing fresh fetches on the next access.
     * @param tokenID - If provided, only clears the cache for this token. Otherwise clears all.
     */
    clearTickSizeCache(tokenID?: string): void;
    getNegRisk(tokenID: string): Promise<boolean>;
    getFeeRateBps(tokenID: string): Promise<number>;
    /**
     * Calculates the hash for the given orderbook
     * @param orderbook
     * @returns
     */
    getOrderBookHash(orderbook: OrderBookSummary): Promise<string>;
    getMidpoint(tokenID: string): Promise<any>;
    getMidpoints(params: BookParams[]): Promise<any>;
    getPrice(tokenID: string, side: string): Promise<any>;
    getPrices(params: BookParams[]): Promise<any>;
    getSpread(tokenID: string): Promise<any>;
    getSpreads(params: BookParams[]): Promise<any>;
    getLastTradePrice(tokenID: string): Promise<any>;
    getLastTradesPrices(params: BookParams[]): Promise<any>;
    getPricesHistory(params: PriceHistoryFilterParams): Promise<MarketPrice[]>;
    /**
     * Creates a new API key for a user
     * @param nonce
     * @returns ApiKeyCreds
     */
    createApiKey(nonce?: number): Promise<ApiKeyCreds>;
    /**
     * Derives an existing API key for a user
     * @param nonce
     * @returns ApiKeyCreds
     */
    deriveApiKey(nonce?: number): Promise<ApiKeyCreds>;
    createOrDeriveApiKey(nonce?: number): Promise<ApiKeyCreds>;
    getApiKeys(): Promise<ApiKeysResponse>;
    getClosedOnlyMode(): Promise<BanStatus>;
    deleteApiKey(): Promise<any>;
    /**
     * Creates a new readonly API key for a user
     * @returns ReadonlyApiKeyResponse
     */
    createReadonlyApiKey(): Promise<ReadonlyApiKeyResponse>;
    getReadonlyApiKeys(): Promise<string[]>;
    /**
     * Deletes a readonly API key for a user
     * @param key The readonly API key to delete
     * @returns boolean
     */
    deleteReadonlyApiKey(key: string): Promise<boolean>;
    /**
     * Validates a readonly API key for a given address
     * @param address The wallet address
     * @param key The readonly API key to validate
     * @returns string
     */
    validateReadonlyApiKey(address: string, key: string): Promise<string>;
    getOrder(orderID: string): Promise<OpenOrder>;
    getTrades(params?: TradeParams, only_first_page?: boolean, next_cursor?: string): Promise<Trade[]>;
    getTradesPaginated(params?: TradeParams, next_cursor?: string): Promise<{
        trades: Trade[];
        next_cursor: string;
        limit: number;
        count: number;
    }>;
    getBuilderTrades(params?: TradeParams, next_cursor?: string): Promise<{
        trades: BuilderTrade[];
        next_cursor: string;
        limit: number;
        count: number;
    }>;
    getNotifications(): Promise<Notification[]>;
    dropNotifications(params?: DropNotificationParams): Promise<void>;
    getBalanceAllowance(params?: BalanceAllowanceParams): Promise<BalanceAllowanceResponse>;
    updateBalanceAllowance(params?: BalanceAllowanceParams): Promise<void>;
    createOrder(userOrder: UserOrder, options?: Partial<CreateOrderOptions>): Promise<SignedOrder>;
    createMarketOrder(userMarketOrder: UserMarketOrder, options?: Partial<CreateOrderOptions>): Promise<SignedOrder>;
    createAndPostOrder<T extends OrderType.GTC | OrderType.GTD = OrderType.GTC>(userOrder: UserOrder, options?: Partial<CreateOrderOptions>, orderType?: T, deferExec?: boolean, postOnly?: boolean): Promise<any>;
    createAndPostMarketOrder<T extends OrderType.FOK | OrderType.FAK = OrderType.FOK>(userMarketOrder: UserMarketOrder, options?: Partial<CreateOrderOptions>, orderType?: T, deferExec?: boolean): Promise<any>;
    getOpenOrders(params?: OpenOrderParams, only_first_page?: boolean, next_cursor?: string): Promise<OpenOrdersResponse>;
    postOrder<T extends OrderType = OrderType.GTC>(order: SignedOrder, orderType?: T, deferExec?: boolean, postOnly?: boolean): Promise<any>;
    postOrders(args: PostOrdersArgs[], deferExec?: boolean, defaultPostOnly?: boolean): Promise<any>;
    cancelOrder(payload: OrderPayload): Promise<any>;
    cancelOrders(ordersHashes: string[]): Promise<any>;
    cancelAll(): Promise<any>;
    /**
     * Sends a heartbeat to the server to keep the session active.
     *
     * If heartbeats are started and one isn't sent within 10s, all orders will be cancelled.
     * Requires Level 2 authentication.
     *
     * Pass the previously returned `heartbeat_id` to chain heartbeats.
     * Pass `undefined`/`null` to start a new heartbeat chain.
     */
    postHeartbeat(heartbeatId?: string | null): Promise<HeartbeatResponse>;
    cancelMarketOrders(payload: OrderMarketCancelParams): Promise<any>;
    isOrderScoring(params?: OrderScoringParams): Promise<OrderScoring>;
    areOrdersScoring(params?: OrdersScoringParams): Promise<OrdersScoring>;
    getEarningsForUserForDay(date: string): Promise<UserEarning[]>;
    getTotalEarningsForUserForDay(date: string): Promise<TotalUserEarning[]>;
    getUserEarningsAndMarketsConfig(date: string, order_by?: string, position?: string, no_competition?: boolean): Promise<UserRewardsEarning[]>;
    getRewardPercentages(): Promise<RewardsPercentages>;
    getCurrentRewards(): Promise<MarketReward[]>;
    getRawRewardsForMarket(conditionId: string): Promise<MarketReward[]>;
    getMarketTradesEvents(conditionID: string): Promise<MarketTradeEvent[]>;
    calculateMarketPrice(tokenID: string, side: Side, amount: number, orderType?: OrderType): Promise<number>;
    createBuilderApiKey(): Promise<BuilderApiKey>;
    getBuilderApiKeys(): Promise<BuilderApiKeyResponse[]>;
    revokeBuilderApiKey(): Promise<any>;
    protected _resolveTickSize(tokenID: string, tickSize?: TickSize): Promise<TickSize>;
    protected get(endpoint: string, options?: RequestOptions): Promise<any>;
    protected post(endpoint: string, options?: RequestOptions): Promise<any>;
    protected put(endpoint: string, options?: RequestOptions): Promise<any>;
    protected del(endpoint: string, options?: RequestOptions): Promise<any>;
    private throwIfError;
    private canL1Auth;
    private canL2Auth;
    private mustBuilderAuth;
    private canBuilderAuth;
    private _resolveFeeRateBps;
    private _generateBuilderHeaders;
    private _getBuilderHeaders;
    /**
     * Opportunistically updates the tick size cache from an order book response.
     */
    private updateTickSizeFromOrderBook;
}
